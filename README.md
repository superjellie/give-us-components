# Give Us Components
## О проекте
Между языком, на котором говорит геймдизайнер и языком на котором надо общаться с компьютером лежит ОГРОМНАЯ пропасть. Игровые движки закрывают её большую часть, поднимая язык на котором мы делаем игры на более абстрактный уровень. Геймдизайнеру (или программисту геймплея) совершенно не обязательно знать о вертексных буфферах, математике кватернионов, аллокаторах и так далее. Работая с игровым движком, мы разговариваем на языке игровых объектов (актёров), компонентов, твёрдых тел, рендереров, материалов (и шейдеров) и так далее. Эти понятия, конечно, сильно ближе к делу, но всё ещё достаточно базовые. 

Мы хотим, чтобы процесс прототипирования и проверки тех или иных элементов игры, проходил как можно быстрее. Но как правило проходит много времени на то, чтобы написать какую-то механику, чтобы потом понять что она не очень хороша и нужна какая-то принципиально иная. Наша задача - это изучить игровые элементы с точки зрения их имплементации (не обращая внимания на их геймдизайнерские качества), обсудить существующие решения по имплементации тех или иных игровых систем и компонентов, помочь друг другу в имплементации игровых элементов, и, возможно, в результате всего этого процесса разработать библиотеки для популярных игровых движков, которые закроют эту пропасть ещё больше.

## Как я могу помочь
Если вы хотите вовлечтся в процесс, вы можете:
- Пройти опрос про повторяющиеся ситуации в геймдеве: TODO
- Или пообщаться по той же теме здесь: https://github.com/superjellie/give-us-components/issues/5
- Попросить помощи в имплементации той или иной игровой механике или поднять другой топик. [См. шаблоны](https://github.com/superjellie/give-us-components/issues/new/choose).
- Присоедениться к какому-то из топиков, если вам кажется что ваше мнение будет полезно.

## Словарь терминов
Программистские термины, с которыми знаком, возможно, не каждый геймдизайнер или начинающий программист:
- Сущность (Entity): Основной участник игрового процесса в движке (`Actor` в UE, `GameObject` в Unity, дерево нодов в Godot).
- Компонент (Component): Скрипт, определяющий часть поведения сущности (юзерские скрипты, наследующиеся от `ActorComponent` в UE, `MonoBehaviour` в Unity, `Node` в Godot).
- Игровая система: Набор компонентов, которые созданы, чтобы работать вместе (Это отличается от понятия системы в ECS. Для нас системы из ECS это Update, EventTick в компонентах, плюса возможно какие-то внешние скрипты, если они нужны; мы не отделяем их от компонентов).
- Имплементация (Implementation): Реализация какого-то игрового элемента в виде кода и код, который реализует этот игровой элемент.
- Интерфейс (Interface): синтаксис и правила использования того или иного компонента, функции, класса, системы. Это отличается от понятия интерфейса используемого в ООП (как интрефейсы в UE блюпринтах или `interface` в C#), хотя эти языковые конструкции пытаются выразить ровно этот смысл. Интерфейс это выражение контракта между тем, кто написал код и тем, кто им будет пользоваться. Если хотя бы одна из двух сторон нарушает этот контракт, в коде появляется баг (ошибка компиляции, ошибка рантайма или латентная ошибка, которая выскочит, только после релиза).
- Дизайн интерфейса (Interface Design): процесс, в котором решается каким интерфейсом должен обладать тот или иной кусок кода, исходя из соображений удобства пользования и имплементации

Мета-термины:
- Топик (Github Issue): термин для гитхабовских вопросов, чтобы не путать их со всем остальным; альтернативные предложения принимаются.
<!-- - Обсуждения (Github Discussions): система чатов в гитхабе. Топики и обсуждения похожи; мы будем использовать топики для более конкретных идей и задач, обсуждения для более свободного общения. В любой момент можно конвертировать один в другой. -->

## Цели 
1. Изучить игровые элементы с точки зрения их имплементации (не обращая внимания на их геймдизайнерские качества).
2. Обсудить существующие решения по имплементации тех или иных игровых систем и компонентов.
3. Помочь друг другу в имплементации игровых элементов.
4. Разработать библиотеки для популярных игровых движков, которые поднимут уровень языка, на которым мы пишем код ближе к геймдизайнерскому.
   
## Программа
Наши задачи состоят в следующем:
1. Поднимать новые топики, для изучения игровых механик. Пытаться осознать какие компоненты и системы нужны для их имплементации.
2. Предлагать идеи по дизайну интерфейса тех или иных компонентов, функций, игровых систем.
3. Документировать обсуждённые системы в вики.
4. Помогать тем, у кого есть вопросы по программированию в движках.
5. Имплементировать те компоненты, которые были хорошо обсуждены в виде библиотек для Unity и UE (может и для Godot'а).

## Философия
### Entity-Component
Одну и ту же задачу можно решить огромным количеством способов, поэтому мы выбираем некую философию, которую надо следовать при поиске решений. Она известна как Entity-Component (EC) или "composition over inheritance" (композиция предпочтительнее наследования). Её суть состоит в следующем:
1. Мир состоит из взаимодействующих друг с другом сущностей (entities).
2. Каждая сущность состоит из набора компонентов (components).
3. Каждый компонент представляет собой скрипт, класс и определяет часть поведения и часть состояния сущности.
4. Компоненты создаются так, чтобы работать как можно более независимо друг от друга, но не до абсурда.

Компонентный подход на самом деле избавляет от необходимости использовать наследование вообще - отсюда второе название. EC используют большинство игровых движков:
- В UE сущности это `Actor`'ы а компоненты это `ActorComponent` и `SceneComponent`'ы.
- В Unity, `GameObject` и `MonoBehaviour` самые классические примеры сущности и компонента.
- Godot использует версию, в которой компоненты несколько более автономны и образуют дерево нодов (`Node`) вместо списка.

Таким образом, когда мы пытаемся имплементировать какой-нибудь игровой элемент, мы на самом деле:
1. Придумываем дизайн интерфейса для компонента или набора компонентов
2. Имплементируем их в движке

### Принцип разделения уровней абстракции
Мы хотим разрабавтывать дизайн нашего кода так, чтобы между разными компонентами и функциями существовало чёткое разграничение уровня абстракции языка, на котором он написан. Функция или компонент более абстрактного уровня, должны использовать функции и компоненты менее абстрактного уровня, но никогда наоборот. Весь код, находящийся в одной функции или одном компоненте должен иметь примерно одинаковый уровень абстракции. Например:
1. Самый асбтрактный язык находится в геймдизайнерском документе.
2. Скрипт сценария фактически повторяет этот документ в более формальной форме.
3. Скрипт сценария будет использовать такие понятия как Игрок, Противник, Генерация уровня и т.д.
4. Игрок и Противник будут знать о Здоровье, Игрок будет знать о Контроллере, Противник об Навмеше, Генерация уровня знает о навмешах и разных мешах которые надо расставлять.
5. Здоровье будет менять отображение в UI, Контроллер двигать Физическое тело в зависимости от ввода.
6. UI, Твёрдое тело, Навмеш имплементированы в движке.
