# Give Us Components
## О проекте
Между языком, на котором говорит геймдизайнер и языком на котором надо общаться с компьютером лежит ОГРОМНАЯ пропасть. Игровые движки закрывают её большую часть, поднимая язык на котором мы делаем игры на более абстрактный уровень. Я думаю, что большинство ничего не слышали о вертексных буфферах или о аллокаторах. Многие даже не знают математику, лежащую за кватернионами или матрицами. Работая с игровым движком, мы разговариваем на языке игровых объектов (актёров), компонентов, твёрдых тел, рендереров, материалов (и шейдеров) и так далее. Эти понятия, конечно, сильно ближе к делу, но всё ещё достаточно базовые. Мы хотим, чтобы процесс прототипирования и проверки тех или иных элементов игры, проходил как можно быстрее. Но как правило проходит много времени на то, чтобы написать какую-то механику, чтобы потом понять что она не очень хороша и нужна какая-то принципиально иная. Наша задача - это изучить игровые элементы с точки зрения их имплементации (не обращая внимания на их геймдизайнерские качества), обсудить существующие решения по имплементации тех или иных игровых систем и компонентов, помочь друг другу в имплементации игровых элементов, и, возможно, в результате всего этого процесса разработать библиотеки для популярных игровых движков, которые закроют эту пропасть ещё больше.
## Словарь терминов
Программистские термины, с которыми знаком, возможно, не каждый геймдизайнер или начинающий программист:
- Сущность (Entity): Основной участник игрового процесса в движке (`Actor` в UE, `GameObject` в Unity, дерево нодов в Godot).
- Компонент (Component): Скрипт, определяющий часть поведения сущности (юзерские скрипты, наследующиеся от `ActorComponent` в UE, `MonoBehaviour` в Unity, `Node` в Godot).
- Игровая система: Набор компонентов, которые созданы, чтобы работать вместе (Это отличается от понятия системы в ECS. Для нас системы из ECS это Update, EventTick в компонентах, плюса возможно какие-то внешние скрипты, если они нужны; мы не отделяем их от компонентов).
- Entity-Component (EC) Философия: [см. ниже](./README.md#Философия) 
- Имплементация (Implementation): Реализация какого-то игрового элемента в виде кода и код, который реализует этот игровой элемент.
- Интерфейс (Interface): синтаксис и правила использования того или иного компонента, функции, класса, системы. Это отличается от понятия интерфейса используемого в ООП (как интрефейсы в UE блюпринтах или `interface` в C#), хотя эти языковые конструкции пытаются выразить ровно этот смысл. Интерфейс это выражение контракта между тем, кто написал код и тем, кто им будет пользоваться. Если хотя бы одна из двух сторон нарушает этот контракт, в коде появляется баг (ошибка компиляции, ошибка рантайма или латентная ошибка, которая выскочит, только после релиза).
- Дизайн интерфейса (Interface Design): процесс, в котором решается каким интерфейсом должен обладать тот или иной кусок кода, исходя из соображений удобства пользования и имплементации.
Мета-термины:
- Топик (Github Issue): термин для гитхабовских вопросов, чтобы не путать их со всем остальным; альтернативные предложения принимаются.

## Цели 
1. Изучить игровые элементы с точки зрения их имплементации (не обращая внимания на их геймдизайнерские качества).
2. Обсудить существующие решения по имплементации тех или иных игровых систем и компонентов.
3. Помочь друг другу в имплементации игровых элементов.
4. Разработать библиотеки для популярных игровых движков, которые поднимут уровень языка, на которым мы пишем код ближе к геймдизайнерскому.
   
## Программа
Наши задачи состоят в следующем:
1. Поднимать новые топики, для изучения игровых механик. Пытаться осознать какие компоненты и системы нужны для их имплементации.
2. Предлагать идеи по дизайну интерфейса тех или иных компонентов, функций, игровых систем.
3. Документировать обсуждённые системы в вики.
4. Помогать тем, у кого есть вопросы по программированию в движках.
5. Имплементировать те компоненты, которые были хорошо обсуждены в виде библиотек для Unity и UE (может и для Godot'а).

## Философия
Одну и ту же задачу можно решить огромным количеством способов, поэтому мы выбираем некую философию, которую надо следовать при поиске решений. Она известна как "Entity-Component философия" или "composition over inheritance" (композиция предпочтительнее наследования). Её суть состоит в следующем:
1. Мир состоит из взаимодействующих друг с другом сущностей (entities).
2. Каждая сущность состоит из набора компонентов (components).
3. Каждый компонент представляет собой скрипт, класс и определяет часть поведения и часть состояния сущности.
4. Компоненты создаются так, чтобы работать как можно более независимо друг от друга, но не до абсурда.

Компонентный подход на самом деле избавляет от необходимости использовать наследование вообще - отсюда второе название. 

Все игровые движки за последние лет 15 переехали на использование этой философии. UE принял её, уже будучи игровым движком с большим количеством ООП, но большая часть нового кода там теперь находится в `ActorComponent`'ах и `SceneComponent`'ах. Unity родился вместе с ней, `GameObject` и `MonoBehaviour` самые естественные примеры сущности и компонента. Godot использует версию, в которой компоненты несколько более автономны и образуют дерево вместо списка.

Основаная проблема скорее в том, что не все программисты знакомы с ней, а образовательные программы не упоминают о ней вообще, предпочитая учить людей (плохому) ООП. 

Таким образом, когда мы ищем решение для какой-либо отдельной игровой системы, мы в основном хотим задизайнить компонет или систему компонентов, решающие задачу.

Данная философия отличается от популярной нынче ECS (Entity-Component-System): ECS больше про производительность и "data-oriented design" вместе с принципом composition-over-inheritance. Можно сказать, что ECS развилась из EC. Более того наш фокус не на имплементации той или иной системы, а больше про увеличение абстрактности языка на котором мы делаем игры. Для тех кому интересно узнать про ECS: https://github.com/SanderMertens/ecs-faq?tab=readme-ov-file. 

Можно также заметить, что EC и ECS это не изобретения последних лет. Ровно тот же принцип лежит в основе любого хорошего ООП кода, который следует приципам SOLID. Проблема в том, что люди ассоциируют с ООП достаточно плохой код, который использует слишком много наследования. Так что в этом смысле EC и ECS это части ООП. 
